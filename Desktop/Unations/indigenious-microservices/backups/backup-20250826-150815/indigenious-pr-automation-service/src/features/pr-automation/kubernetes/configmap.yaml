apiVersion: v1
kind: ConfigMap
metadata:
  name: pr-automation-config
  namespace: indigenious
  labels:
    app: pr-automation
    component: config
data:
  # Application Configuration
  app.json: |
    {
      "name": "PR Automation Service",
      "version": "1.0.0",
      "environment": "production",
      "features": {
        "strategicOperations": true,
        "contentWarfare": true,
        "networkAmplification": true,
        "crisisExploitation": true,
        "seoDomaination": true
      },
      "security": {
        "mfaRequired": true,
        "sessionTimeout": 1800000,
        "maxLoginAttempts": 5,
        "lockoutDuration": 3600000
      }
    }
  
  # CORS Configuration
  cors.json: |
    {
      "origin": [
        "https://indigenious.ca",
        "https://www.indigenious.ca",
        "https://app.indigenious.ca"
      ],
      "credentials": true,
      "maxAge": 86400,
      "allowedHeaders": [
        "Content-Type",
        "Authorization",
        "X-CSRF-Token",
        "X-Request-ID",
        "X-Device-Fingerprint"
      ],
      "exposedHeaders": [
        "X-Request-ID",
        "X-RateLimit-Limit",
        "X-RateLimit-Remaining",
        "X-RateLimit-Reset"
      ]
    }
  
  # Rate Limiting Configuration
  rate-limits.json: |
    {
      "global": {
        "windowMs": 60000,
        "max": 100
      },
      "auth": {
        "login": {
          "windowMs": 900000,
          "max": 5
        },
        "register": {
          "windowMs": 3600000,
          "max": 3
        }
      },
      "pr": {
        "createOperation": {
          "windowMs": 3600000,
          "max": 5
        },
        "executeOperation": {
          "windowMs": 86400000,
          "max": 10
        },
        "contentGeneration": {
          "windowMs": 3600000,
          "max": 50
        }
      }
    }
  
  # Nginx Configuration
  nginx.conf: |
    user nginx;
    worker_processes auto;
    error_log /var/log/nginx/error.log warn;
    pid /var/run/nginx.pid;
    
    events {
        worker_connections 4096;
        use epoll;
        multi_accept on;
    }
    
    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;
        
        # Security headers
        add_header X-Frame-Options "DENY" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()" always;
        
        # SSL Configuration
        ssl_protocols TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_stapling on;
        ssl_stapling_verify on;
        
        # Logging
        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';
        
        access_log /var/log/nginx/access.log main;
        
        # Performance
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;
        keepalive_timeout 65;
        types_hash_max_size 2048;
        client_max_body_size 10m;
        
        # Gzip
        gzip on;
        gzip_vary on;
        gzip_proxied any;
        gzip_comp_level 6;
        gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss application/rss+xml application/atom+xml image/svg+xml;
        
        # Rate limiting zones
        limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
        limit_req_zone $binary_remote_addr zone=auth:10m rate=2r/s;
        limit_req_zone $binary_remote_addr zone=pr:10m rate=5r/s;
        
        include /etc/nginx/conf.d/*.conf;
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: pr-automation-scripts
  namespace: indigenious
  labels:
    app: pr-automation
    component: scripts
data:
  # Database initialization script
  init-db.sql: |
    -- Create schemas
    CREATE SCHEMA IF NOT EXISTS pr_automation;
    CREATE SCHEMA IF NOT EXISTS audit;
    CREATE SCHEMA IF NOT EXISTS security;
    
    -- Enable extensions
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    CREATE EXTENSION IF NOT EXISTS "pgcrypto";
    CREATE EXTENSION IF NOT EXISTS "pg_stat_statements";
    
    -- Create audit tables
    CREATE TABLE IF NOT EXISTS audit.logs (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      level VARCHAR(20) NOT NULL,
      category VARCHAR(50) NOT NULL,
      action VARCHAR(100) NOT NULL,
      user_id UUID,
      request_id VARCHAR(100),
      session_id VARCHAR(100),
      ip_address INET,
      user_agent TEXT,
      details JSONB,
      metadata JSONB,
      hash VARCHAR(64) NOT NULL,
      previous_hash VARCHAR(64),
      sequence_number BIGSERIAL,
      signature TEXT
    );
    
    -- Create security tables
    CREATE TABLE IF NOT EXISTS security.sessions (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      user_id UUID NOT NULL,
      token_hash VARCHAR(64) NOT NULL UNIQUE,
      device_fingerprint VARCHAR(64),
      ip_address INET,
      user_agent TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      expires_at TIMESTAMPTZ NOT NULL,
      last_activity TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      revoked BOOLEAN DEFAULT FALSE,
      revoked_at TIMESTAMPTZ,
      revoked_reason TEXT
    );
    
    CREATE TABLE IF NOT EXISTS security.failed_attempts (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      identifier VARCHAR(255) NOT NULL,
      attempt_type VARCHAR(50) NOT NULL,
      ip_address INET,
      user_agent TEXT,
      attempted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      details JSONB
    );
    
    -- Create PR operations tables
    CREATE TABLE IF NOT EXISTS pr_automation.operations (
      id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
      codename VARCHAR(100) NOT NULL,
      type VARCHAR(50) NOT NULL,
      status VARCHAR(50) NOT NULL DEFAULT 'pending',
      created_by UUID NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      started_at TIMESTAMPTZ,
      completed_at TIMESTAMPTZ,
      narrative_encrypted TEXT NOT NULL,
      tactics_encrypted TEXT NOT NULL,
      risks JSONB NOT NULL,
      metadata JSONB
    );
    
    -- Create indexes
    CREATE INDEX idx_audit_logs_timestamp ON audit.logs(timestamp DESC);
    CREATE INDEX idx_audit_logs_user_id ON audit.logs(user_id);
    CREATE INDEX idx_audit_logs_category_action ON audit.logs(category, action);
    CREATE INDEX idx_sessions_user_id ON security.sessions(user_id);
    CREATE INDEX idx_sessions_expires_at ON security.sessions(expires_at);
    CREATE INDEX idx_failed_attempts_identifier ON security.failed_attempts(identifier);
    CREATE INDEX idx_operations_status ON pr_automation.operations(status);
    CREATE INDEX idx_operations_created_by ON pr_automation.operations(created_by);
    
    -- Enable row-level security
    ALTER TABLE pr_automation.operations ENABLE ROW LEVEL SECURITY;
    ALTER TABLE security.sessions ENABLE ROW LEVEL SECURITY;
    
    -- Create policies
    CREATE POLICY operations_isolation ON pr_automation.operations
      FOR ALL TO application_user
      USING (created_by = current_setting('app.current_user_id')::uuid);
    
    CREATE POLICY sessions_isolation ON security.sessions
      FOR ALL TO application_user
      USING (user_id = current_setting('app.current_user_id')::uuid);
  
  # Health check script
  health-check.sh: |
    #!/bin/sh
    set -e
    
    # Check if the service is responsive
    response=$(curl -sf http://localhost:3001/api/pr/health || echo "FAILED")
    
    if [ "$response" = "FAILED" ]; then
      echo "Health check failed: Service not responding"
      exit 1
    fi
    
    # Check if database is accessible
    db_check=$(echo "$response" | grep -o '"database":"[^"]*"' | cut -d'"' -f4)
    if [ "$db_check" != "healthy" ]; then
      echo "Health check failed: Database unhealthy"
      exit 1
    fi
    
    # Check if Redis is accessible
    redis_check=$(echo "$response" | grep -o '"redis":"[^"]*"' | cut -d'"' -f4)
    if [ "$redis_check" != "healthy" ]; then
      echo "Health check failed: Redis unhealthy"
      exit 1
    fi
    
    echo "Health check passed"
    exit 0